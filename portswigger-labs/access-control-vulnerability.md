# Access Control Vulnerability – URL-based access control bypass

## Lab: URL-based access control can be circumvented


## Lab Info

This lab contains an access control vulnerability in an admin panel.  
Although access to the `/admin` path is blocked at the front-end level, the backend application trusts the `X-Original-URL` HTTP header, which allows the restriction to be bypassed.


## Goal

Access the admin panel and delete the user **carlos**.


## Logic Overview

- The application has an **unauthenticated admin panel** located at `/admin`.
- Direct access to this path is blocked by a **front-end control**.
- The backend application is deployed behind a **reverse proxy** and supports the `X-Original-URL` header.
- The backend incorrectly trusts this header to determine the requested resource.

If the `X-Original-URL` header is controlled by the client, it can be abused to bypass access control checks.


## Step 1 – Understanding the `X-Original-URL` Header

`X-Original-URL` is an HTTP header commonly used by reverse proxies and web servers to forward the original requested URL to the backend application after URL rewriting or routing.

It allows the backend to understand which resource the client initially requested.  
If a backend application incorrectly trusts this header and allows clients to control it, it may lead to authorization or access control bypass vulnerabilities.


## Step 2 – Inspecting the Admin Panel Access

When attempting to access the admin panel directly:

![Access denied response](images/ACCESS-DENIED.png)


The application responds with an **Access Denied** message, indicating that access is blocked at the front-end level.


## Step 3 – Bypassing the Restriction Using `X-Original-URL`

The request is sent to **Burp Suite Repeater**, where it is modified as follows:

![Modified](images/X-Original-URL.png)


After resending the request, the server responds with **HTTP 200**, and the admin panel becomes accessible.

This confirms that the backend trusts the `X-Original-URL` header to determine access permissions.

---

## Step 4 – Identifying the Delete Endpoint

Inside the admin panel, a delete functionality is found for user management.

Searching for the username **carlos**, the following delete endpoint is identified:

![Delete Endpoint](images/LOCATING-CARLOS.png)

## Step 5 – Deleting the User "carlos"

The delete request is crafted using the same bypass technique:

![Technique](images/DELETING-USER.png)


After sending the request, the user **carlos** is successfully deleted, completing the lab.


## Result

- Access control was bypassed using the `X-Original-URL` header.
- Unauthorized access to the admin panel was achieved.
- The target user **carlos** was successfully deleted.


## Security Impact

This vulnerability allows attackers to bypass front-end access controls and directly access restricted backend functionality.


## Mitigation

- Do not trust client-controlled headers such as `X-Original-URL` for authorization decisions.
- Enforce access control checks at the backend application level.
- Strip or validate proxy-related headers before processing requests.



## Lab 2: Method-based access control can be circumvented

## Logic:

This lab implements access controls that rely partly on the HTTP method used in requests.

The application includes an admin panel that can be accessed by logging in with the credentials:

```
Username: administrator
Password: admin
```

## Goal:

The goal is to log in as a normal user and exploit the flawed access controls to escalate privileges and become an administrator.

Log in as the user **wiener** and promote to administrator.

## Step 1 - Understanding the admin’s requests

First, we log in as administrator to observe how the application performs privileged actions.

As an example, we upgrade another user (Carlos) to inspect:

- the request URL

- the HTTP method

- request parameters

- the server response

![Upgrade Response](images/admin's-request.png)

From the captured request, we observe:

- The action is performed via a POST request

- The request includes parameters such as:
    ```
    username

    action=upgrade
    ```

This confirms that user role changes are handled by a backend endpoint that relies on the HTTP method.

## Step 2 – Replaying the request as a normal user

Next, we log in as the user **wiener**.

We reuse our own session cookie and attempt to send the same POST request used by the administrator.

![User's Request](images/unauthorized.png)

The server responds with an “Unauthorized” message, indicating that direct reuse of the admin request is blocked.

## Step 3 – Testing alternative HTTP methods

Since the lab description mentions method-based access control, we test whether the backend enforces authorization consistently across different HTTP methods.

We resend the same request but change the HTTP method.

![Modified Request](images/final-version.png)

This time, the server responds with a redirect back to /admin, identical to the response received when the real administrator upgrades a user.

This confirms that:

- Authorization checks are enforced for one HTTP method, but missing or broken for another.

As a result, our account is successfully promoted to administrator, and the lab is solved.

## Security Impact

This vulnerability demonstrates why authorization must never depend on HTTP methods alone.

Backends must:

-Enforce role checks on every request regardless of HTTP method, and never trust client-controlled behavior.

# Lab 3 – Multi-step process with no access control on one step

## Goal
Log in as `wiener:peter` and exploit the flawed access controls to promote your own account to **administrator**.

## Lab Info / Logic
This lab contains an admin panel with a **multi-step** workflow for changing a user’s role.  
The vulnerability is that **one step in this workflow is missing proper access control**.

You can observe the intended admin behavior by logging in with:

- `administrator:admin`


## Step 1 – Observe the admin workflow (multi-step role change)

After logging in as `administrator`, upgrading a user triggers **two separate requests**.

### Request #1 – Initial "upgrade" action (step 1)
This request is sent immediately after clicking the **Upgrade** button.

![Admin upgrade request – step 1](images/admin-upgrade-step1.png)

When I tried to replay this request as `wiener` (by swapping the session cookie), the application responded with **Unauthorized**.

This suggests that **step 1 is protected**.

---

### Request #2 – Confirmation request (step 2)
A second request is sent to **confirm** the role change before it is applied.

![Admin upgrade confirmation – step 2](images/admin-upgrade-step2.png)

Unlike step 1, this confirmation step is not consistently protected.

---

## Step 2 – Exploit the unprotected step as a normal user

1. Log in as `wiener:peter` and capture your session cookie.
2. Send the **confirmation request (step 2)** using your own session.
3. Set the target username to your own account (`wiener`).

Because the confirmation endpoint lacks proper access control, the request succeeds and the user is promoted.

---

## Result
Successfully escalated privileges and became an administrator by abusing a multi-step workflow where **one step lacked authorization checks**.

---

## Why this works (short explanation)
Multi-step processes are common (e.g., “request → confirm”).  
If authorization is only enforced on **some** steps, an attacker can skip the protected step and directly call the weak one.

---

## Mitigation
- Enforce authorization checks on **every step** of sensitive workflows.
- Do not assume earlier steps “protect” later ones.
- Validate the current user’s role server-side before applying role changes.


# Lab 4 -- Referer-Based Access Control

## Lab Description

This lab implements access control for certain administrative functions based on the HTTP **Referer** header.

The application checks whether requests to sensitive admin endpoints originate from an authorized page by validating the `Referer` value. This client-side trust can be abused to bypass access controls.

**Objective:**  
Log in as `wiener:peter` and exploit the flawed access control mechanism to promote yourself to an administrator.

---

## Initial Analysis

To understand how the application enforces access control, we first log in as the administrator:

```
administrator:admin
```


By observing the admin panel behavior and HTTP traffic in **Burp Suite**, we analyze how a user promotion request is handled.

---

## Step 1 – Analyze Admin Promotion Request

While logged in as the administrator, intercept the request responsible for promoting a user to admin:

![Original Request](images/original-request.png)

### Observations

- The request targets an admin-only endpoint.
- A valid `Referer` header is present.
- No additional server-side authorization checks are performed.

This indicates that access control relies heavily on the `Referer` header.

---

## Step 2 – Attempt the Same Request as a Normal User

Log in using the standard user credentials:

```
wiener:peter
```


Attempt to access the same admin endpoint directly:

![Our Request](images/our-request.png)

### Result

- Server responds with **401 Unauthorized**

This confirms the access restriction is based on the `Referer` value.

---

## Step 3 – Bypass Access Control via Referer Header

Replay the original admin request in **Burp Repeater** with the following modifications:

- Replace the admin session cookie with `wiener`’s session
- Manually add a valid `Referer` header

Example:

![Final Form](images/final-form.png)


Changing the cookie of the administrator's original request also works.

---

## Result

- Server responds with a **302 redirect**, identical to the admin response
- The user `wiener` is successfully promoted to administrator
- The lab is solved

---

## Conclusion

This lab demonstrates a **Referer-based access control vulnerability**, where the application trusts client-supplied headers for authorization.

### Key Takeaways

- Client-controlled headers must never be trusted for access control
- Authorization must be enforced server-side
- Burp Suite is effective for identifying and exploiting flawed access logic













